// Generated by CoffeeScript 1.3.3
(function() {
  var LazyLines,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  LazyLines = (function() {
    var nCode, onChunkReceived, onLineEndFound, onStreamEnd, rCode, _ref;

    _ref = ['\r'.charCodeAt(0), '\n'.charCodeAt(0)], rCode = _ref[0], nCode = _ref[1];

    function LazyLines(stream) {
      var _this = this;
      this.stream = stream;
      if (!(this instanceof LazyLines)) {
        return new LazyLines(this.stream);
      }
      this.bufferedChunks = [];
      this.bufferedLength = 0;
      this.actions = [];
      this.encoding = 'utf-8';
      this.stream.on('data', function() {
        return onChunkReceived.apply(_this, arguments);
      });
      this.stream.on('end', function() {
        return onStreamEnd.apply(_this, arguments);
      });
    }

    onChunkReceived = function(chunk) {
      var chr, firstUnhandledIndex, i, _i, _len;
      firstUnhandledIndex = 0;
      for (i = _i = 0, _len = chunk.length; _i < _len; i = ++_i) {
        chr = chunk[i];
        if (chr === rCode || chr === nCode) {
          this.bufferedChunks.push(chunk.slice(0, firstUnhandledIndex, i));
          this.bufferedLength += i - firstUnhandledIndex;
          onLineEndFound.call(this, chunk, i);
          if (chr === rCode && chunk[i + 1] === nCode) {
            i += 1;
          }
          firstUnhandledIndex = i + 1;
        }
      }
      this.bufferedChunks.push(chunk.slice(firstUnhandledIndex));
      return this.bufferedLength += chunk.length - firstUnhandledIndex;
    };

    onStreamEnd = function() {
      if (this.bufferedLength > 0) {
        return onLineEndFound.call(this);
      }
    };

    onLineEndFound = function() {
      var action, bufferedChunk, line, targetLength, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
      if (this.encoding != null) {
        line = (_ref1 = bufferedChunk.toString(this.encoding), __indexOf.call(this.bufferedChunks, _ref1) >= 0).join('');
      } else {
        line = new Buffer(this.bufferedLength);
        targetLength = 0;
        _ref2 = this.bufferedChunks;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          bufferedChunk = _ref2[_i];
          bufferedChunk.copy(line, targetLength);
          targetLength += bufferedChunk.length;
        }
      }
      this.bufferedChunks = [];
      this.bufferedLength = 0;
      _ref3 = this.actions;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        action = _ref3[_j];
        switch (action.type) {
          case 'forEach':
            action.f(line);
            break;
          case 'map':
            line = action.f(line);
            break;
          case 'filter':
            if (action.f(line) === false) {
              return;
            }
        }
      }
    };

    LazyLines.prototype.setEncoding = function(encoding) {
      this.encoding = encoding;
      return this;
    };

    LazyLines.prototype.forEach = function(f) {
      this.actions.push({
        type: 'forEach',
        f: f
      });
      return this;
    };

    LazyLines.prototype.map = function(f) {
      this.actions.push({
        type: 'map',
        f: f
      });
      return this;
    };

    LazyLines.prototype.filter = function(f) {
      this.actions.push({
        type: 'filter',
        f: f
      });
      return this;
    };

    return LazyLines;

  })();

  module.exports = LazyLines;

}).call(this);
