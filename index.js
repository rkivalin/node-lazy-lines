// Generated by CoffeeScript 1.3.3
(function() {
  var LazyLines;

  LazyLines = (function() {
    var nCode, onChunkReceived, onLineEndFound, onStreamEnd, rCode, _ref;

    _ref = ['\r'.charCodeAt(0), '\n'.charCodeAt(0)], rCode = _ref[0], nCode = _ref[1];

    function LazyLines(stream) {
      var _this = this;
      this.stream = stream;
      if (!(this instanceof LazyLines)) {
        return new LazyLines(this.stream);
      }
      this.bufferedChunks = [];
      this.bufferedLength = 0;
      this.actions = [];
      this.encoding = 'utf-8';
      this.stream.on('data', function() {
        return onChunkReceived.apply(_this, arguments);
      });
      this.stream.on('end', function() {
        return onStreamEnd.apply(_this, arguments);
      });
    }

    onChunkReceived = function(chunk) {
      var chr, firstUnhandledIndex, i, _i, _len;
      firstUnhandledIndex = 0;
      for (i = _i = 0, _len = chunk.length; _i < _len; i = ++_i) {
        chr = chunk[i];
        if (chr === rCode || chr === nCode) {
          this.bufferedChunks.push(chunk.slice(firstUnhandledIndex, i));
          this.bufferedLength += i - firstUnhandledIndex;
          onLineEndFound.call(this);
          if (chr === rCode && chunk[i + 1] === nCode) {
            i += 1;
          }
          firstUnhandledIndex = i + 1;
        }
      }
      if (firstUnhandledIndex !== chunk.length) {
        this.bufferedChunks.push(chunk.slice(firstUnhandledIndex));
        return this.bufferedLength += chunk.length - firstUnhandledIndex;
      }
    };

    onStreamEnd = function() {
      if (this.bufferedLength > 0) {
        return onLineEndFound.call(this);
      }
    };

    onLineEndFound = function() {
      var action, bufferedChunk, line, targetLength, _i, _j, _len, _len1, _ref1, _ref2;
      if (this.encoding != null) {
        line = ((function() {
          var _i, _len, _ref1, _results;
          _ref1 = this.bufferedChunks;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            bufferedChunk = _ref1[_i];
            _results.push(bufferedChunk.toString(this.encoding));
          }
          return _results;
        }).call(this)).join('');
      } else {
        line = new Buffer(this.bufferedLength);
        targetLength = 0;
        _ref1 = this.bufferedChunks;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          bufferedChunk = _ref1[_i];
          bufferedChunk.copy(line, targetLength);
          targetLength += bufferedChunk.length;
        }
      }
      this.bufferedChunks = [];
      this.bufferedLength = 0;
      _ref2 = this.actions;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        action = _ref2[_j];
        switch (action.type) {
          case 'forEach':
            action.f(line);
            break;
          case 'map':
            line = action.f(line);
            break;
          case 'filter':
            if (action.f(line) === false) {
              return;
            }
        }
      }
    };

    LazyLines.prototype.setEncoding = function(encoding) {
      this.encoding = encoding;
      return this;
    };

    LazyLines.prototype.forEach = function(f) {
      this.actions.push({
        type: 'forEach',
        f: f
      });
      return this;
    };

    LazyLines.prototype.map = function(f) {
      this.actions.push({
        type: 'map',
        f: f
      });
      return this;
    };

    LazyLines.prototype.filter = function(f) {
      this.actions.push({
        type: 'filter',
        f: f
      });
      return this;
    };

    return LazyLines;

  })();

  module.exports = LazyLines;

}).call(this);
